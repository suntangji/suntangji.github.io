---
title: 一道题加深了对闭包的理解
date: 2018-05-20 12:08:46
tags: 学习笔记
category: Python
---
最近在知乎上看到了一道关于Python的面试题，加深了我对闭包的理解。
<!--more-->
面试题是这样的
``` python
def testfun():
      return [lambda x: i * x for i in range(4)]
  
  
for every in testfun():
    print(every(2))

```
我觉得答案是0、2、4、6，看到正确答案是6、6、6、6我大吃一惊。仔细思考了一会原来是因为闭包所以才会这样。
可以先把列表生成式分解
``` python
#!/usr/bin/env python                                                                  
# -*- coding: utf-8 -*-
  
  
def testfun():
    # return [lambda x: i * x for i in range(4)]
    lists = []
    for i in range(4):
        lists.append(lambda x: x * i)
  
    return lists
  
  
for every in testfun():
    print(every(2))
```
这段代码执行一段循环，每循环一次向列表中添加一个匿名函数，匿名函数引用了外层函数中得变量i,外层函数返回的列表中包含了内层函数，所以构成了一个闭包，外层函数的i在外层函数执行结束后也不会立刻释放，于是匿名函数就变成了 lambda x: x*3, 所以执行结果是4个6.
要想得到预期的0、2、4、6，可以有一下几种解决方法

- 使用默认参数

``` p#!/usr/bin/env python
# -*- coding: utf-8 -*-


def testfun():
    return [lambda x, i=i: i * x for i in range(4)]


for every in testfun():
    print(every(2))

```

- 使用生成器

``` python
#!/usr/bin/env python
# -*- coding: utf-8 -*-


def testfun():
    return (lambda x: i * x for i in range(4))


for every in testfun():
    print(every(2))

```
或者使用yield
``` python
#!/usr/bin/env python
# -*- coding: utf-8 -*-


def testfun():
    # return (lambda x: i * x for i in range(4))
    for i in range(4):
        yield lambda x: x * i


for every in testfun():
    print(every(2))

```
生成式在调用时才去计算i的值

- 使用偏函数

``` python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from functools import partial
from operator import mul


def testfun():
    return [partial(mul, i) for i in range(4)]


for every in testfun():
    print(every(2))

```
偏函数相当于给i设置了一个默认值