---
title: 判断一个字符串是否是另一个字符串翻转后的结果
date: 2017-08-02 15:31:44
tags: 学习笔记
category: C 
---
字符串abcdef向左翻转一位的结果为fabcde,向右翻转翻转一位的结果为bcdefa.向左翻转两位的结果为efabcd,向右翻转两位的结果为cdefab。
<!--more-->
要判断一个字符串是否是另一个字符串翻转后的结果，必须遍历向左翻转和向右翻转0-len(arr)-1位的所有情况。

我定义了一个翻转函数reverse，返回值为空，参数为两个指针，第一个是翻转的起始地址，第二个是翻转的结束地址。要想实现向左翻转n位的效果，先对字符串整体翻转，然后把第n位，到len(arr)-1位进行翻转就得到了向左翻转的结果。要实现向右翻转，也是对整体翻转，然后把第0位到第n位进行翻转就得到了向右翻转的结果。

为了节约空间，我没有开辟其他数组，所以每次翻转后，还需要把字符串恢复为原始的abcdef。
实现代码如下
```c 
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
void reverse(char* begin, char* end)
{
	int tmp = 0;
	//char* p = begin;
	while (begin< end)
	{
		tmp = *begin;
		*begin = *end;
		*end = tmp;
		begin++;
		end--;
	}

}
int cmp_reverse(char arr[], char arr2[],int len,char * begin)
{
	if (strcmp(arr, arr2) == 0)
	{
		return 1;
	}
	for (int i = 1; i < len; i++)
	{
		reverse(begin, begin + len-1);
		reverse(begin+i, begin + len-1);
		if (strcmp(arr, arr2) == 0)
		{
			return 1;
		}
		else
		{
			reverse(begin + i, begin + len - 1);
			reverse( begin, begin + len - 1);

		}
	}
	for (int i = 1; i < len; i++)
	{
		reverse(begin, begin + len - 1);
		reverse(begin , begin+ len -1 -i);
		reverse(begin + len - i, begin + len - 1);
		if (strcmp(arr, arr2) == 0)
		{
			return 1;
		}
		else
		{
			reverse(begin + len - i, begin + len - 1);
			reverse(begin, begin + len - 1 - i);
			reverse(begin, begin + len -1);
			

		}
	}
	return 0;
}
int main()
{
	char arr[] = "abcdef";
	char arr2[] = "cdefab";
	int len = strlen(arr);
	char * begin = arr;
	//char * end = &arr[len - 1];
	//char * p = end;
	if (cmp_reverse(arr,arr2,len,begin) == 1)
		printf("y");
	else
		printf("n");
		
	
	//printf("%s", arr);
	system("pause");
	return 0;
}
```