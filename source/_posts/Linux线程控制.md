---
title: Linux线程控制
date: 2018-05-07 10:41:39
tags: 学习笔记
category: linux
---
在Linux下，程序或可执行文件是一个静态的实体，它只是一组指令的集合，进程是程序运行后的实例，是一个动态的实体。进程是资源竞争的基本单位，而线程是一种轻量级进程，是操作系统进行调度的最小单元。一个进程可能包含多个线程。
<!--more-->
#### 已经有进程了为什么还需要线程
有人说线程没有必要，线程的应用场景多进程也可以做到。Unix原本的设计是没有线程的，更倾向于使用进程。线程的引入反而给Unix家族带来了一系列的麻烦，很多函数不是线程安全的，信号机制也因为线程变得更加复杂。在单核CPU时代，多线程需求并不强烈，随着多核时代的到来处理器开始支持超线程和多核架构，为了充分发挥多核处理器的强大功能，使程序性能得到提升，线程开始被大量使用。

#### 进程和线程的区别
进程之间的虚拟地址空间是独立的，但线程会共享虚拟地址空间。同一进程下的线程间共享全局内存区域，包括初始化数据段、未初始化数据段、动态分配的堆内存段。这种共享使线程创建、终止、切换、通信的开销更小。

#### 线程间共享和私有的部分
共享
- 共享同一地址空间，文本段、数据段共享
- 文件描述符表
- 信号处理方式
- 当前工作目录
- 用户id、组id

私有
- 线程id
- 上下文信息(各种寄存器的值、程序计数器、栈指针)
- 栈空间
- errno变量
- 信号屏蔽字
- 调度优先级

#### 线程的优缺点
优点
- 创建线程的开销要小于创建进程
- 线程调度的开销小于进程调度
- 线程占用的资源比进程小
- 可以充分利用CPU的多核资源

缺点
- 线程之间共享地址空间，让进程变得更加脆弱，一个线程挂掉，该进程下的所有线程都要完蛋。
- 易出错、难定位。无法保证各个线程承担的任务相等，还存在死锁、饿死、活锁、竞态条件等问题

#### 进程id和线程id
在Linux中目前的线程实现是轻量级进程(Light Weighted Process),每一个用户态的线程，在内核中都对应一个调度实体，也拥有自己的进程描述符(task_struct结构体)。多进程的线程，又被称为线程组，线程组内每一个线程都有一个进程描述符。进程描述符中的pid对应线程id,tgid对应进程id.线程id的本质是内存地址。

#### pthread库

POSIX函数 | 函数功能描述
:---: | :---:
pthread_create | 创建一个线程
pthread_self | 获取线程id
pthread_equal | 判断两个线程id是否相等
pthread_join | 阻塞式的等待线程退出
pthread_detach | 设置线程分离，结束后自动回收
pthread_exit | 终止线程
pthread_cancel | 取消线程
pthread_cleanup_push pthread_cleanup_pop | 线程退出后注册和执行清理函数


